
/////////////////////////////////////////////////////////////////////////////
//
//      File:           hpl_pd_pristine.hmdes2
//      Authors:        Shail Aditya
//      Created:        January, 1996
//      Description:    HPL-PD Architecture Description
//
/////////////////////////////////////////////////////////////////////////////
// HPL-PD Machine Architecture Description (IFMB model)

// Preliminary conversion of PLAYDOH.hmdes1 to hmdes2 format.
// Written by Shail Aditya 01/16/96
// Based on John C. Gyllenhaal's example of PA_7100_pristine.hmdes2
// Based on Rick Hank's PLAYDOH.hmdes1

// Modified by Shail Aditya 3/3/98 
// Updated to conform to exact HPL-PD opcodes and IO Formats
// Based on Vinod Kathail's HPL-PD ISA specification

// **************************************************************
// Registers and Register Files

$def bit_size 1
$def byte_size 8
$def hw_size   16
$def word_size 32
$def sgl_size  32
$def dbl_size  64

$def speculation 1

$def !num_int_param_reg 4
$def !num_flt_param_reg 4
$def !num_dbl_param_reg 4
$def !num_pv_reg	8

SECTION Register_Class
{
  CALLER();
  CALLEE();
  READ_ONLY();
  PSEUDO();
  ALIAS();
}

SECTION Macro_Class
{
  LOCAL(class(PSEUDO));
  PARAM(class(PSEUDO));
  SWAP(class(PSEUDO));
  INT_RETURN_TYPE(class(PSEUDO));
  FLT_RETURN_TYPE(class(PSEUDO));
  DBL_RETURN_TYPE(class(PSEUDO));
  INT_RETURN();
  $for (N in $1..(num_int_param_reg)) { "INT_PARAM_${N}"(); }
  FLT_RETURN();
  $for (N in $1..(num_flt_param_reg)) { "FLT_PARAM_${N}"(); }  
  DBL_RETURN();
  $for (N in $1..(num_dbl_param_reg)) { "DBL_PARAM_${N}"(); }  
  INT_TM_TYPE(class(PSEUDO));
  FLT_TM_TYPE(class(PSEUDO));
  DBL_TM_TYPE(class(PSEUDO));
  SP_REG();				// Stack pointer
  FP_REG();				// Frame pointer
  IP_REG(alias(SP_REG));		// Incoming parameter space
  OP_REG(alias(SP_REG));		// Outgoing parameter space
  LV_REG(alias(SP_REG));		// Local variable space
  RGS_REG(alias(SP_REG));		// Register swap space
  LC_REG();				// Loop Counter
  ESC_REG();				// Epilogue stage counter
  ALL_ROT_PRED();			// All the rotating predicate registers
  ALL_PRED(alias(ALL_ROT_PRED));	// The entire predicate register file
  ALL_STATIC_PRED(alias(ALL_ROT_PRED));	
  RRB();	
  RETURN_ADDR();
  FLT_ZERO(class(READ_ONLY));
  FLT_ONE(class(READ_ONLY));
  DBL_ZERO(class(READ_ONLY));
  DBL_ONE(class(READ_ONLY));
  INT_ZERO(class(READ_ONLY));
  PRED_FALSE(class(READ_ONLY));
  PRED_TRUE(class(READ_ONLY));
  SPILL_TEMPREG();
  $for (N in $0..(num_pv_reg-1)) { "PV_${N}"(class(ALIAS)); }  

  // PC Base Macros for WIMS
  PCB_t();
  PCB_f();
}

SECTION Register
{
  // For loop defines all registers
  $for (clust in $0..(num_clusters-1)) {	
    $for (N in $0..(gpr_static_size/2-1)) { "GPR_${clust}_${N}"(class(CALLER)); }
    $for (N in $(gpr_static_size/2)..(gpr_static_size-1)) { "GPR_${clust}_${N}"(class(CALLEE)); }
    $for (N in $0..(gpr_rotating_size-1)) { "GPR_${clust}[${N}]"(); }
	
    $for (N in $0..(fpr_static_size-1)) { "FPR_${clust}_${N}"(class(CALLER)); }
    $for (N in $0..(fpr_rotating_size-1)) { "FPR_${clust}[${N}]"(); }

    $for (N in $0..(pr_static_size-1)) { "PR_${clust}_${N}"(class(CALLER)); }
    $for (N in $0..(pr_rotating_size-1)) { "PR_${clust}[${N}]"(); }

    $for (N in $0..(btr_static_size-1)) { "BTR_${clust}_${N}"(class(CALLER)); }

    // TBD: need to use control register names from the HPL-PD manual
    // and define their aliasing relationship with other registers.
    $for (N in $0..(cr_static_size-1)) { "CR_${clust}_${N}"(class(CALLER)); }

    // WIMS dynamic loop cache register files
    $for (N in $0..(wpr_static_size-1)) {"WPR_${clust}_${N}"(class(CALLER)); }
	
    $for (N in $0..(pcb_static_size-1)) {"PCB_${clust}_${N}"(class(CALLER)); }

  }

  // ORing other attributes (macro definitions) to registers defined above.

  'GPR_0_0'  (macro || (SP_REG));
  'GPR_0_1'  (macro || (FP_REG));
  
  'GPR_0_10'  (macro || (INT_ZERO));	
  'GPR_0_11'  (macro || (INT_PARAM_1));	
  'GPR_0_12'  (macro || (INT_PARAM_2));	
  'GPR_0_13'  (macro || (INT_PARAM_3));	
  'GPR_0_14'  (macro || (INT_PARAM_4));	
  'GPR_0_16'  (macro || (INT_RETURN));	
  
  'GPR_0_4'  (macro || (SPILL_TEMPREG));

  'CR_0_0' (macro || (LC_REG));
  'CR_0_1' (macro || (ESC_REG));
  'PR_0_0' (macro || (ALL_ROT_PRED));

  'FPR_0_0'  (macro || (FLT_ZERO));
  'FPR_0_1'  (macro || (FLT_PARAM_1));
  'FPR_0_2'  (macro || (FLT_PARAM_2));
  'FPR_0_3'  (macro || (FLT_PARAM_3));
  'FPR_0_4'  (macro || (FLT_PARAM_4));
  'FPR_0_5'  (macro || (FLT_RETURN));
  'FPR_0_6'  (macro || (FLT_ONE));
	 	
  'BTR_0_1'  (macro || (RETURN_ADDR));
	
  'FPR_0_20' (macro || (DBL_ZERO));	
  'FPR_0_21' (macro || (DBL_PARAM_1));	
  'FPR_0_22' (macro || (DBL_PARAM_2));		
  'FPR_0_23' (macro || (DBL_PARAM_3));	
  'FPR_0_24' (macro || (DBL_PARAM_4));		
  'FPR_0_25' (macro || (DBL_RETURN));	
  'FPR_0_26'  (macro || (DBL_ONE));

  'PCB_0_1' (macro || (PCB_t));
  'PCB_0_2' (macro || (PCB_f));
}

SECTION Register_File
{
  $for (clust in $0..(num_clusters-1)) {	
    GPR_${clust}(static($for (N in $0..(gpr_static_size-1)) { "GPR_${clust}_${N}" })
      	         rotating($for (N in $0..(gpr_rotating_size-1)) { "GPR_${clust}[${N}]" }) 
                 width(${word_size}) speculative(${speculation}) virtual(I));

    FPR_${clust}(static($for (N in $0..(fpr_static_size-1)) { "FPR_${clust}_${N}" })
                 rotating($for (N in $0..(fpr_rotating_size-1)) { "FPR_${clust}[${N}]" }) 
                 width(${dbl_size}) speculative(${speculation}) virtual(F));

    PR_${clust}(static($for (N in $0..(pr_static_size-1)) { "PR_${clust}_${N}" })
                 rotating($for (N in $0..(pr_rotating_size-1)) { "PR_${clust}[${N}]" }) 
                 width(1) speculative(${speculation}) virtual(P));

    BTR_${clust}(static($for (N in $0..(btr_static_size-1)) { "BTR_${clust}_${N}" })
                 rotating() width(${dbl_size}) speculative(0) virtual(B));

    CR_${clust}(static($for (N in $0..(cr_static_size-1)) { "CR_${clust}_${N}" })
                rotating() width(${word_size}) speculative(0) virtual(C));

    // WIMS register files , bound to virtual P?? 
    WPR_${clust}(static($for (N in $0..(wpr_static_size-1)) { "WPR_${clust}_${N}" })
                 width(${bit_size}) speculative(0) virtual(P));

    PCB_${clust}(static($for (N in $0..(pcb_static_size-1)) { "PCB_${clust}_${N}" })
                 width(${word_size}) speculative(0) virtual(I));

  }

//  L(width(0) speculative(0) virtual(L));
  U(width(0) speculative(0) virtual(U));

  // HPL-PD 2.0 extn
  $def max_short  $={1<<(${short_lit_size}-1)}
  $def max_memory $={1<<(${memory_lit_size}-1)}
  $def max_branch $={1<<(${branch_lit_size}-1)}
  $def max_long   $={1<<(${long_lit_size}-1)}
  $def max_unrestricted   $={1<<(32-1)}

  s(width(short_lit_size) virtual(L) 
    intrange($={0-${max_short}} $={${max_short}-1}));
  m(width(memory_lit_size) virtual(L) 
    intrange($={0-${max_memory}} $={${max_memory}-1}));
  n(width(branch_lit_size) virtual(L)
    intrange($={0-${max_branch}} $={${max_branch}-1}));
  o(width(long_lit_size) virtual(L) 
    intrange($={0-${max_long}} $={${max_long}-1}));
  l(width(unrestricted_lit_size) virtual(L) 
    intrange($={0-${max_unrestricted}} $={${max_unrestricted}-1}));

}

// **************************************************************
// Operation Formats (IO Descriptors)

SECTION Field_Type
{
  $for (clust in $0..(num_clusters-1)) {
    FT_i_${clust}(regfile(GPR_${clust}));
    FT_f_${clust}(regfile(FPR_${clust}));
    FT_p_${clust}(regfile(PR_${clust}));
    FT_c_${clust}(regfile(CR_${clust}));
    FT_b_${clust}(regfile(BTR_${clust}));
    FT_w_${clust}(regfile(WPR_${clust}));
    FT_r_${clust}(regfile(PCB_${clust}));
  }

  FT_l(regfile(l));
  FT_u(regfile(U));
  // HPL-PD 2.0 extn
  FT_s(regfile(s));
  FT_m(regfile(m));
  FT_n(regfile(n));
  FT_o(regfile(o));
 
  $for (clust in $0..(num_clusters-1)) {
    FT_ic_${clust}(compatible_with(FT_i_${clust} FT_c_${clust}));
    FT_il_${clust}(compatible_with(FT_i_${clust} FT_l));
 
    FT_icb_${clust}(compatible_with(FT_i_${clust} FT_c_${clust} FT_b_${clust}));
    FT_icl_${clust}(compatible_with(FT_i_${clust} FT_c_${clust} FT_l));
    FT_ilb_${clust}(compatible_with(FT_i_${clust} FT_l FT_b_${clust}));
    FT_iclb_${clust}(compatible_with(FT_i_${clust} FT_c_${clust} FT_l FT_b_${clust}));
    FT_ifc_${clust}(compatible_with(FT_i_${clust} FT_f_${clust} FT_c_${clust}));
    FT_ifcl_${clust}(compatible_with(FT_i_${clust} FT_f_${clust} FT_c_${clust} FT_l));

    FT_icfbpu_${clust}(compatible_with(FT_i_${clust} FT_c_${clust} FT_f_${clust} FT_b_${clust} FT_p_${clust} FT_u));
    FT_icfbplu_${clust}(compatible_with(FT_i_${clust} FT_c_${clust} FT_f_${clust} FT_b_${clust} FT_p_${clust} FT_l FT_u));

    FT_pw_${clust}(compatible_with(FT_p_${clust} FT_w_${clust}));
    FT_ol(compatible_with(FT_o FT_l));
    FT_ir_${clust}(compatible_with(FT_i_${clust} FT_r_${clust}));
  }

  // Create field types compatible for all clusters for dummy ops.
  FT_p_all(compatible_with (
    $for (clust in $0..(num_clusters-1)) {	
	FT_p_${clust}})
  );
  FT_i_all(compatible_with (
    $for (clust in $0..(num_clusters-1)) {	
	FT_i_${clust}})
  );
  FT_ifcl_all(compatible_with (
    $for (clust in $0..(num_clusters-1)) {	
	FT_i_${clust} FT_c_${clust} FT_f_${clust} 
    }
    FT_l)
  );

  FT_icfbpu_all(compatible_with (
    $for (clust in $0..(num_clusters-1)) {	
	FT_i_${clust} FT_c_${clust} FT_f_${clust} FT_b_${clust} FT_p_${clust} 
    }
    FT_u)
  );
  FT_icfbplu_all(compatible_with(
    $for (clust in $0..(num_clusters-1)) {	
 	FT_i_${clust} FT_c_${clust} FT_f_${clust} FT_b_${clust} FT_p_${clust} 
    }
    FT_l FT_u)
  );

}

SECTION Operation_Format
{
  $for (clust in $0..(num_clusters-1)) {

    OF_intarith1_${clust}(pred(FT_p_${clust}) src(FT_icl_${clust}) dest(FT_ic_${clust}));
    OF_intarith2_${clust}(pred(FT_p_${clust}) src(FT_icl_${clust} FT_icl_${clust}) dest(FT_ic_${clust}));
    OF_intarith3_${clust}(pred(FT_p_${clust}) src(FT_icl_${clust} FT_icl_${clust} FT_icl_${clust}) dest(FT_ic_${clust}));
    OF_intcmpr_${clust}(pred(FT_p_${clust}) src(FT_il_${clust} FT_il_${clust}) dest(FT_i_${clust}));
    OF_intcmpp_${clust}(pred(FT_p_${clust}) src(FT_il_${clust} FT_il_${clust}) dest(FT_p_${clust} FT_p_${clust}));
    // HPL-PD 2.0 Extn: One target compare-to-predicate operation
    // OF_intcmppi(pred(FT_p) src(FT_il FT_il) dest(FT_p));

    OF_floatarith1_${clust}(pred(FT_p_${clust}) src(FT_f_${clust}) dest(FT_f_${clust}));
    OF_floatarith2_${clust}(pred(FT_p_${clust}) src(FT_f_${clust} FT_f_${clust}) dest(FT_f_${clust}));
    OF_floatarith3_${clust}(pred(FT_p_${clust}) src(FT_f_${clust} FT_f_${clust} FT_f_${clust}) dest(FT_f_${clust}));
    OF_floatcmpr_${clust}(pred(FT_p_${clust}) src(FT_f_${clust} FT_f_${clust}) dest(FT_i_${clust}));
    OF_floatcmpp_${clust}(pred(FT_p_${clust}) src(FT_f_${clust} FT_f_${clust}) dest(FT_p_${clust} FT_p_${clust}));
    // HPL-PD 2.0 Extn: One target compare-to-predicate operation
    // OF_floatcmppi(pred(FT_p) src(FT_f FT_f) dest(FT_p));

    // TBD: B as destination for BTR save/restore
    OF_intload_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_icb_${clust}));
    OF_floatload_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_f_${clust}));
    OF_intloadinc_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_icl_${clust}) dest(FT_icb_${clust} FT_i_${clust}));
    OF_intloadgdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_icb_${clust}));
    OF_intloadmdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_icb_${clust}));
    
    /*new integer load w/ sign extension LGX, LMX and LX (tangw 05-17-02)*/
    OF_intloadext_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_icb_${clust}));
    OF_intloadgdispext_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_icb_${clust}));
    OF_intloadmdispext_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_icb_${clust}));

    /*new floating point load FG & FM (tangw 05-17-02)*/	
    OF_floatloadgdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_f_${clust}));
    OF_floatloadmdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_f_${clust}));

    OF_floatloadinc_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_icl_${clust}) dest(FT_f_${clust} FT_i_${clust}));

    // TBD: B as source for BTR save/restore
    OF_intstore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_iclb_${clust}) dest());  
    OF_floatstore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_f_${clust}) dest());  
    OF_intstoreinc_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_iclb_${clust} FT_icl_${clust}) dest(FT_i_${clust}));
    OF_floatstoreinc_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_f_${clust} FT_icl_${clust}) dest(FT_i_${clust}));

    /*new integer store operations SG & SM & floating point store FLM & FLG(tangw 05-17-02)*/
    OF_intstoregdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust} FT_iclb_${clust}) dest());
    OF_intstoremdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust} FT_iclb_${clust}) dest());
    OF_floatstoregdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust} FT_f_${clust}) dest());
    OF_floatstoremdisp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust} FT_f_${clust}) dest());

    OF_predload_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_p_${clust}));
    OF_predstore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_p_${clust}) dest());  

    // Explicit save/restore formats - Shail Aditya 05/26/98
    OF_intsave_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_ic_${clust}) dest());
    OF_intrestore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_ic_${clust}));
    OF_floatsave_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_f_${clust}) dest());
    OF_floatrestore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_f_${clust}));
    OF_brsave_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_b_${clust}) dest());
    OF_brrestore_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_b_${clust}));

    // TBD: B as src and dest for BTR moves

    OF_sext_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_i_${clust}));
    OF_moveif_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_f_${clust}));
    OF_movefi_${clust}(pred(FT_p_${clust}) src(FT_f_${clust}) dest(FT_i_${clust}));
    OF_moveip_${clust}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_p_${clust}));
    OF_movepi_${clust}(pred(FT_p_${clust}) src(FT_p_${clust}) dest(FT_i_${clust}));
    OF_pred_${clust}(pred() src() dest(FT_p_${clust}));

    // Move/extract bits to/from pred -- Shail Aditya 05/26/98
    OF_movegbp_${clust}(pred(FT_p_${clust}) src(FT_i_${clust} FT_il_${clust}) dest(FT_p_${clust}));
    OF_movegcm_${clust}(pred(FT_p_${clust}) src(FT_il_${clust} FT_il_${clust} FT_c_${clust}) dest(FT_c_${clust}));

    // HPL-PD 2.0 extn
    // For literal moves
    // intlitmove modified to include PCB moves for WIMS
    OF_intlitmove_${clust}(pred(FT_pw_${clust}) src(FT_ol) dest(FT_ir_${clust}));
    OF_floatlitmove_${clust}(pred(FT_p_${clust}) src(FT_o) dest(FT_f_${clust}));
    // For new split moves instead of move

    // For literal moves and pbrs
    OF_btrlitmove_${clust}(pred(FT_p_${clust}) src(FT_n) dest(FT_b_${clust}));
    OF_pbrlit_${clust}(pred(FT_p_${clust}) src(FT_n FT_n) dest(FT_b_${clust}));

    // For WIMS moves of literal to PCB. (pnagarka)
    //OF_pcb_move_${clust}(pred(FT_m_${clust}) src(FT_l_${clust}) dest(FT_r_${clust}));

    // For WIMS copy op (pnagarka)
    OF_lc_copy_${clust}(pred() src(FT_l FT_l FT_l) dest(FT_w_${clust}));

    // TBD: added B on first src operand for PBR operations -- SAG 10/28/97
    OF_branch_${clust}(pred(FT_p_${clust}) src(FT_ilb_${clust} FT_l) dest(FT_b_${clust}));
    OF_brucond_${clust}(pred(FT_p_${clust}) src(FT_b_${clust}) dest());
    OF_brcond_${clust}(pred(FT_p_${clust}) src(FT_b_${clust} FT_p_${clust}) dest());
    OF_brlink_${clust}(pred(FT_p_${clust}) src(FT_b_${clust}) dest(FT_b_${clust}));
    OF_brtop_${clust}(pred() src(FT_b_${clust} FT_c_${clust} FT_c_${clust}) dest(FT_p_${clust} FT_c_${clust} FT_c_${clust}));
    OF_brlc_${clust}(pred(FT_p_${clust}) src(FT_b_${clust} FT_c_${clust}) dest(FT_c_${clust}));

    OF_brdvi_${clust}(pred(FT_p_${clust}) src(FT_b_${clust} FT_i_${clust}) dest());
    OF_brdvf_${clust}(pred(FT_p_${clust}) src(FT_b_${clust} FT_f_${clust}) dest());
  }

  $for (clust in $0..(num_clusters-1)) {
    $for (clust2 in $0..(num_clusters-1)) {
      OF_moveii_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_iclb_${clust}) dest(FT_icb_${clust2}));
      OF_moveff_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_f_${clust}) dest(FT_f_${clust2}));
      OF_movepp_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_p_${clust}) dest(FT_p_${clust2}));
      OF_movegg_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_i_${clust2}));
      OF_movebb_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_b_${clust}) dest(FT_b_${clust2}));
      OF_movegc_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_i_${clust}) dest(FT_c_${clust2}));
      OF_movecg_${clust}_${clust2}(pred(FT_p_${clust}) src(FT_c_${clust}) dest(FT_i_${clust2}));
    }
  }
}

// **************************************************************
//  Latency Classes

SECTION Operand_Latency
{
  // latency times
  time_null(time(0));

  time_int_alu_sample(time(int_alu_sample));
  time_int_alu_exception(time(int_alu_exception));
  time_int_alu_latency(time(int_alu_latency));
  time_int_alu_reserve(time(int_alu_reserve));

  time_int_cmpp_sample(time(int_cmpp_sample));
  time_int_cmpp_exception(time(int_cmpp_exception));
  time_int_cmpp_latency(time(int_cmpp_latency));
  time_int_cmpp_reserve(time(int_cmpp_reserve));

  time_int_multiply_sample(time(int_multiply_sample));
  time_int_multiply_exception(time(int_multiply_exception));
  time_int_multiply_latency(time(int_multiply_latency));
  time_int_multiply_reserve(time(int_multiply_reserve));
  time_int_multiply_add_sample(time(int_multiply_add_sample));

  time_int_divide_sample(time(int_divide_sample));
  time_int_divide_exception(time(int_divide_exception));
  time_int_divide_latency(time(int_divide_latency));
  time_int_divide_reserve(time(int_divide_reserve));

  time_float_alu_sample(time(float_alu_sample));
  time_float_alu_exception(time(float_alu_exception));
  time_float_alu_latency(time(float_alu_latency));
  time_float_alu_reserve(time(float_alu_reserve));

  time_float_cmpp_sample(time(float_cmpp_sample));
  time_float_cmpp_exception(time(float_cmpp_exception));
  time_float_cmpp_latency(time(float_cmpp_latency));
  time_float_cmpp_reserve(time(float_cmpp_reserve));

  time_float_multiply_sample(time(float_multiply_sample));
  time_float_multiply_exception(time(float_multiply_exception));
  time_float_multiply_latency(time(float_multiply_latency));
  time_float_multiply_reserve(time(float_multiply_reserve));

  time_float_divide_sample(time(float_divide_sample));
  time_float_divide_exception(time(float_divide_exception));
  time_float_divide_latency(time(float_divide_latency));
  time_float_divide_reserve(time(float_divide_reserve));

  time_post_increment_add(time(post_increment_add));

  time_load_level1_sample(time(load_level1_sample));
  time_load_level1_exception(time(load_level1_exception));
  time_load_level1_latency(time(load_level1_latency));
  time_load_level1_reserve(time(load_level1_reserve));

  time_load_level2_sample(time(load_level2_sample));
  time_load_level2_exception(time(load_level2_exception));
  time_load_level2_latency(time(load_level2_latency));
  time_load_level2_reserve(time(load_level2_reserve));

  time_load_level3_sample(time(load_level3_sample));
  time_load_level3_exception(time(load_level3_exception));
  time_load_level3_latency(time(load_level3_latency));
  time_load_level3_reserve(time(load_level3_reserve));

  time_dsload_level1_sample(time(dsload_level1_sample));
  time_dsload_level1_exception(time(dsload_level1_exception));
  time_dsload_level1_latency(time(dsload_level1_latency));
  time_dsload_level1_reserve(time(dsload_level1_reserve));

  time_dsload_level2_sample(time(dsload_level2_sample));
  time_dsload_level2_exception(time(dsload_level2_exception));
  time_dsload_level2_latency(time(dsload_level2_latency));
  time_dsload_level2_reserve(time(dsload_level2_reserve));

  time_dsload_level3_sample(time(dsload_level3_sample));
  time_dsload_level3_exception(time(dsload_level3_exception));
  time_dsload_level3_latency(time(dsload_level3_latency));
  time_dsload_level3_reserve(time(dsload_level3_reserve));

  time_store_sample(time(store_sample));
  time_store_exception(time(store_exception));
  time_store_latency(time(store_latency));
  time_store_reserve(time(store_reserve));

  time_dsload_verify_sample(time(dsload_verify_sample));
  time_dsload_verify_exception(time(dsload_verify_exception));
  time_dsload_verify_latency(time(dsload_verify_latency));
  time_dsload_verify_reserve(time(dsload_verify_reserve));

  time_branch_sample(time(branch_sample));
  time_branch_exception(time(branch_exception));
  time_branch_latency(time(branch_latency));
  time_branch_reserve(time(branch_reserve));

  // HPL-PD 2.0 Extn
  $if ($?{local_memory_units}) {
    time_load_localmem_sample(time(load_localmem_sample));
    time_load_localmem_exception(time(load_localmem_exception));
    time_load_localmem_latency(time(load_localmem_latency));
    time_load_localmem_reserve(time(load_localmem_reserve));
  
    time_store_localmem_sample(time(store_localmem_sample));
    time_store_localmem_exception(time(store_localmem_exception));
    time_store_localmem_latency(time(store_localmem_latency));
    time_store_localmem_reserve(time(store_localmem_reserve));
  }
}

SECTION Operation_Latency
{
  OL_null(exc(time_null) 
	  rsv(time_null
	      time_null
	      time_null
	      time_null) 
 	  pred(time_null) 
	  src(time_null 
	      time_null 
	      time_null 
	      time_null) 
	  sync_src(time_null
                   time_null) 
	  dest(time_null
               time_null
               time_null
               time_null) 
	  sync_dest(time_null
		    time_null));

  OL_int(exc(time_int_alu_exception) 
	 rsv(time_int_alu_reserve
	     time_int_alu_reserve
	     time_int_alu_reserve
	     time_int_alu_reserve) 
 	 pred(time_int_alu_sample) 
	 src(time_int_alu_sample 
	     time_int_alu_sample 
	     time_int_alu_sample 
	     time_int_alu_sample) 
	 sync_src(time_int_alu_sample
                  time_int_alu_sample) 
	 dest(time_int_alu_latency
              time_int_alu_latency
              time_int_alu_latency
              time_int_alu_latency) 
	 sync_dest(time_int_alu_sample
		   time_int_alu_sample));

  OL_float(exc(time_float_alu_exception) 
	   rsv(time_float_alu_reserve
	       time_float_alu_reserve
	       time_float_alu_reserve
	       time_float_alu_reserve) 
 	   pred(time_float_alu_sample) 
	   src(time_float_alu_sample 
	       time_float_alu_sample 
	       time_float_alu_sample 
	       time_float_alu_sample) 
	   sync_src(time_float_alu_sample
                    time_float_alu_sample) 
	   dest(time_float_alu_latency
                time_float_alu_latency
                time_float_alu_latency
                time_float_alu_latency) 
	   sync_dest(time_float_alu_sample
		     time_float_alu_sample));

  OL_load1(exc(time_load_level1_exception) 
	   rsv(time_load_level1_reserve
	       time_load_level1_reserve
	       time_load_level1_reserve
	       time_load_level1_reserve)
  	   pred(time_load_level1_sample) 
	   src(time_load_level1_sample 
	       time_load_level1_sample 
	       time_load_level1_sample 
	       time_load_level1_sample) 
	   sync_src(time_load_level1_sample
                    time_load_level1_sample) 
	   dest(time_load_level1_latency
                time_post_increment_add
                time_load_level1_latency
                time_load_level1_latency) 
	   sync_dest(time_load_level1_sample
		     time_load_level1_sample));

  OL_load2(exc(time_load_level2_exception) 
	   rsv(time_load_level2_reserve
	       time_load_level2_reserve
	       time_load_level2_reserve
	       time_load_level2_reserve) 
 	   pred(time_load_level2_sample) 
	   src(time_load_level2_sample 
	       time_load_level2_sample 
	       time_load_level2_sample 
	       time_load_level2_sample) 
	   sync_src(time_load_level2_sample
                    time_load_level2_sample) 
	   dest(time_load_level2_latency
                time_post_increment_add
                time_load_level2_latency
                time_load_level2_latency) 
	   sync_dest(time_load_level2_sample
		     time_load_level2_sample));

  OL_load3(exc(time_load_level3_exception) 
	   rsv(time_load_level3_reserve
		time_load_level3_reserve
		time_load_level3_reserve
		time_load_level3_reserve) 
   	   pred(time_load_level3_sample) 
	   src(time_load_level3_sample 
	       time_load_level3_sample 
	       time_load_level3_sample 
	       time_load_level3_sample) 
	   sync_src(time_load_level3_sample
                    time_load_level3_sample) 
	   dest(time_load_level3_latency
                time_post_increment_add
                time_load_level3_latency
                time_load_level3_latency) 
	   sync_dest(time_load_level3_sample
		   time_load_level3_sample));

  OL_dsload1(exc(time_dsload_level1_exception) 
	     rsv(time_dsload_level1_reserve
		 time_dsload_level1_reserve
		 time_dsload_level1_reserve
		 time_dsload_level1_reserve) 
 	     pred(time_dsload_level1_sample) 
	     src(time_dsload_level1_sample 
	         time_dsload_level1_sample 
	         time_dsload_level1_sample 
	         time_dsload_level1_sample) 
	     sync_src(time_dsload_level1_sample
                      time_dsload_level1_sample) 
	     dest(time_dsload_level1_latency
                  time_post_increment_add
                  time_dsload_level1_latency
                  time_dsload_level1_latency) 
	     sync_dest(time_dsload_level1_sample
		       time_dsload_level1_sample));

  OL_dsload2(exc(time_dsload_level2_exception) 
	     rsv(time_dsload_level2_reserve
		 time_dsload_level2_reserve
		 time_dsload_level2_reserve
		 time_dsload_level2_reserve) 
 	     pred(time_dsload_level2_sample) 
	     src(time_dsload_level2_sample 
	         time_dsload_level2_sample 
	         time_dsload_level2_sample 
	         time_dsload_level2_sample) 
	     sync_src(time_dsload_level2_sample
                      time_dsload_level2_sample) 
	     dest(time_dsload_level2_latency
                  time_post_increment_add
                  time_dsload_level2_latency
                  time_dsload_level2_latency) 
	     sync_dest(time_dsload_level2_sample
		       time_dsload_level2_sample));

  OL_dsload3(exc(time_dsload_level3_exception) 
	     rsv(time_dsload_level3_reserve
		 time_dsload_level3_reserve
		 time_dsload_level3_reserve
		 time_dsload_level3_reserve) 
 	     pred(time_dsload_level3_sample) 
	     src(time_dsload_level3_sample 
	         time_dsload_level3_sample 
	         time_dsload_level3_sample 
	         time_dsload_level3_sample) 
	     sync_src(time_dsload_level3_sample
                      time_dsload_level3_sample) 
	     dest(time_dsload_level3_latency
                  time_post_increment_add
                  time_dsload_level3_latency
                  time_dsload_level3_latency) 
	     sync_dest(time_dsload_level3_sample
		       time_dsload_level3_sample));

  OL_dsload_verify(exc(time_dsload_verify_exception) 
	     rsv(time_dsload_verify_reserve
		 time_dsload_verify_reserve
		 time_dsload_verify_reserve
		 time_dsload_verify_reserve) 
 	     pred(time_dsload_verify_sample) 
	     src(time_dsload_verify_sample 
	         time_dsload_verify_sample 
	         time_dsload_verify_sample 
	         time_dsload_verify_sample) 
	     sync_src(time_dsload_verify_latency
                      time_dsload_verify_sample) 
	     dest(time_dsload_verify_latency
                  time_dsload_verify_latency
                  time_dsload_verify_latency
                  time_dsload_verify_latency) 
	     sync_dest(time_dsload_verify_latency
		       time_dsload_verify_latency));

  OL_store(exc(time_store_exception) 
	   rsv(time_store_reserve
		time_store_reserve
		time_store_reserve
		time_store_reserve) 
 	   pred(time_store_sample) 
	   src(time_store_sample 
	       time_store_sample 
	       time_store_sample 
	       time_store_sample) 
	   sync_src(time_store_sample
                    time_store_sample) 
	   dest(time_store_latency
                time_store_latency
                time_store_latency
                time_store_latency) 
	   sync_dest(time_store_latency
		     time_store_latency));

  OL_branch(exc(time_branch_exception) 
	    rsv(time_branch_reserve
		time_branch_reserve
		time_branch_reserve
		time_branch_reserve) 
 	    pred(time_branch_sample) 
	    src(time_branch_sample 
	        time_branch_sample 
	        time_branch_sample 
	        time_branch_sample) 
	    sync_src(time_branch_sample
                     time_branch_sample) 
	    dest(time_branch_latency
                 time_branch_latency
                 time_branch_latency
                 time_branch_latency) 
	    sync_dest(time_branch_latency
		      time_branch_latency));

  OL_intcmpp(exc(time_int_cmpp_exception) 
	     rsv(time_int_cmpp_reserve
		 time_int_cmpp_reserve
		 time_int_cmpp_reserve
		 time_int_cmpp_reserve) 
 	     pred(time_int_cmpp_sample) 
	     src(time_int_cmpp_sample 
	         time_int_cmpp_sample 
	         time_int_cmpp_sample 
	         time_int_cmpp_sample) 
	     sync_src(time_int_cmpp_sample
                      time_int_cmpp_sample) 
	     dest(time_int_cmpp_latency
                  time_int_cmpp_latency
                  time_int_cmpp_latency
                  time_int_cmpp_latency) 
	     sync_dest(time_int_cmpp_sample
		       time_int_cmpp_sample));

  OL_intmpy(exc(time_int_multiply_exception) 
	    rsv(time_int_multiply_reserve
		time_int_multiply_reserve
		time_int_multiply_reserve
		time_int_multiply_reserve) 
 	    pred(time_int_multiply_sample) 
	    src(time_int_multiply_sample 
	        time_int_multiply_sample 
	        time_int_multiply_add_sample 
	        time_int_multiply_sample) 
	    sync_src(time_int_multiply_sample
                     time_int_multiply_sample) 
	    dest(time_int_multiply_latency
                 time_int_multiply_latency
                 time_int_multiply_latency
                 time_int_multiply_latency) 
	    sync_dest(time_int_multiply_sample
		      time_int_multiply_sample));

  OL_intdiv(exc(time_int_divide_exception) 
	    rsv(time_int_divide_reserve
		 time_int_divide_reserve
		 time_int_divide_reserve
		 time_int_divide_reserve) 
 	    pred(time_int_divide_sample) 
	    src(time_int_divide_sample 
	        time_int_divide_sample 
	        time_int_divide_sample 
	        time_int_divide_sample) 
	    sync_src(time_int_divide_sample
                     time_int_divide_sample) 
	    dest(time_int_divide_latency
                 time_int_divide_latency
                 time_int_divide_latency
                 time_int_divide_latency) 
	    sync_dest(time_int_divide_sample
		      time_int_divide_sample));

  OL_floatcmpp(exc(time_float_cmpp_exception) 
	       rsv(time_float_cmpp_reserve
		   time_float_cmpp_reserve
		   time_float_cmpp_reserve
		   time_float_cmpp_reserve) 
 	       pred(time_float_cmpp_sample) 
	       src(time_float_cmpp_sample 
	           time_float_cmpp_sample 
	           time_float_cmpp_sample 
	           time_float_cmpp_sample) 
	       sync_src(time_float_cmpp_sample
                        time_float_cmpp_sample) 
	       dest(time_float_cmpp_latency
                    time_float_cmpp_latency
                    time_float_cmpp_latency
                    time_float_cmpp_latency) 
	       sync_dest(time_float_cmpp_sample
		    time_float_cmpp_sample));

  OL_floatmpy(exc(time_float_multiply_exception) 
	      rsv(time_float_multiply_reserve
		  time_float_multiply_reserve
		  time_float_multiply_reserve
		  time_float_multiply_reserve) 
 	      pred(time_float_multiply_sample) 
	      src(time_float_multiply_sample 
	          time_float_multiply_sample 
	          time_float_multiply_sample 
	          time_float_multiply_sample) 
	      sync_src(time_float_multiply_sample
                       time_float_multiply_sample) 
	      dest(time_float_multiply_latency
                   time_float_multiply_latency
                   time_float_multiply_latency
                   time_float_multiply_latency) 
	      sync_dest(time_float_multiply_sample
		        time_float_multiply_sample));

  OL_floatdiv(exc(time_float_divide_exception) 
	      rsv(time_float_divide_reserve
		   time_float_divide_reserve
		   time_float_divide_reserve
		   time_float_divide_reserve) 
 	      pred(time_float_divide_sample) 
	      src(time_float_divide_sample 
	          time_float_divide_sample 
	          time_float_divide_sample 
	          time_float_divide_sample) 
	      sync_src(time_float_divide_sample
                       time_float_divide_sample) 
	      dest(time_float_divide_latency
                   time_float_divide_latency
                   time_float_divide_latency
                   time_float_divide_latency) 
	      sync_dest(time_float_divide_sample
		        time_float_divide_sample));

  // HPL-PD 2.0 Extn
  $if ($?{local_memory_units}) {

  OL_load_localmem(exc(time_load_localmem_exception) 
	           rsv(time_load_localmem_reserve
		       time_load_localmem_reserve
		       time_load_localmem_reserve
		       time_load_localmem_reserve)
 	           pred(time_load_localmem_sample) 
	           src(time_load_localmem_sample 
	               time_load_localmem_sample 
	               time_load_localmem_sample 
	               time_load_localmem_sample) 
	           sync_src(time_load_localmem_sample
                            time_load_localmem_sample) 
	           dest(time_load_localmem_latency
                        time_post_increment_add
                        time_load_localmem_latency
                        time_load_localmem_latency) 
	           sync_dest(time_load_localmem_sample
		             time_load_localmem_sample));

  OL_store_localmem(exc(time_store_localmem_exception) 
	            rsv(time_store_localmem_reserve
		        time_store_localmem_reserve
		        time_store_localmem_reserve
		        time_store_localmem_reserve) 
 	            pred(time_store_localmem_sample) 
	            src(time_store_localmem_sample 
	                time_store_localmem_sample 
	                time_store_localmem_sample 
	                time_store_localmem_sample) 
	            sync_src(time_store_localmem_sample
                             time_store_localmem_sample) 
	            dest(time_store_localmem_latency
                         time_store_localmem_latency
                         time_store_localmem_latency
                         time_store_localmem_latency) 
	            sync_dest(time_store_localmem_latency
		              time_store_localmem_latency));
  }
}

// *************************************************************
// Resource Description

SECTION Resource
{
  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      R_${clust}_${idx}();
    }
    // HPL-PD 2.0 Extn
    $if (${local_memory_units} != 0) {
      $for (idx in $0..(local_memory_units-1)) {
        R_${clust}_lm${idx}();
      }
    }
  } 
}

// Right now we have a basic 0th cycle resource usage for each resource

SECTION Resource_Usage
{
  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      RU_${clust}_${idx}(use(R_${clust}_${idx}) time(0));
    }
  }
}

// Right now we have a simple model of one resource usage per reservation table
SECTION Reservation_Table
{
  RT_null(use());

  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      RT_${clust}_${idx}(use(RU_${clust}_${idx}));
    }
  }
}

// *************************************************************
// Scheduling Alternatives

// Scheduling Alternative describes a unit specific alternative.

SECTION Scheduling_Alternative
{

  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      SA_intarith1_int_${clust}_${idx}(format(OF_intarith1_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_int_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_intshift_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_intsatadd_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      SA_intarith2_intsataddl_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_intsatsub_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_intsatsubl_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intarith2_intdiv_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_intdiv) resv(RT_${clust}_${idx}));
      SA_intarith2_intmpy_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith2_intsatmpy_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith2_intsatmpyl_${clust}_${idx}(format(OF_intarith2_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith3_intsatmpyadd_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith3_intsatmpyaddn_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith3_intsatmpysub_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith3_intsatmpyrsub_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));
      SA_intarith3_intmpy_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_intmpy) resv(RT_${clust}_${idx}));

      SA_intcmpr_int_${clust}_${idx}(format(OF_intcmpr_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_intcmpp_int_${clust}_${idx}(format(OF_intcmpp_${clust}) latency(OL_intcmpp) resv(RT_${clust}_${idx}));
      SA_sext_int_${clust}_${idx}(format(OF_sext_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      SA_moveip_int_${clust}_${idx}(format(OF_moveip_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movepi_int_${clust}_${idx}(format(OF_movepi_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_pred_int_${clust}_${idx}(format(OF_pred_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      // Move/extract bits to/from pred -- Shail Aditya 05/26/98
      SA_movegbp_int_${clust}_${idx}(format(OF_movegbp_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movegcm_int_${clust}_${idx}(format(OF_movegcm_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      // HPL-PD 2.0 Extn
      SA_intlitmove_int_${clust}_${idx}(format(OF_intlitmove_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_btrlitmove_int_${clust}_${idx}(format(OF_btrlitmove_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_pbrlit_int_${clust}_${idx}(format(OF_pbrlit_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
 
      // Agressive pred_clear, pred_set
      SA_pred_null_${clust}_${idx}(format(OF_pred_${clust}) latency(OL_int) resv(RT_null));
      SA_branch_int_${clust}_${idx}(format(OF_branch_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      // Intra-cluster moves
      SA_moveii_int_${clust}_${clust}_${idx}(format(OF_moveii_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movepp_int_${clust}_${clust}_${idx}(format(OF_movepp_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movegg_int_${clust}_${clust}_${idx}(format(OF_movegg_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movebb_int_${clust}_${clust}_${idx}(format(OF_movebb_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movegc_int_${clust}_${clust}_${idx}(format(OF_movegc_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
      SA_movecg_int_${clust}_${clust}_${idx}(format(OF_movecg_${clust}_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
	      
      // Bit extraction ops	
      SA_bit_extraction_${clust}_${idx}(format(OF_intarith3_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));

      // WIMS pcb move
      //SA_pcb_move_int_${clust}_${idx}(format(OF_pcb_move_${clust}) latency(OL_int) resv(RT_${clust}_${idx});
      SA_lc_copy_int_${clust}_${idx}(format(OF_lc_copy_${clust}) latency(OL_int) resv(RT_${clust}_${idx}));
    }
  }

  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      SA_floatarith1_float_${clust}_${idx}(format(OF_floatarith1_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
      SA_floatarith1_floatdiv_${clust}_${idx}(format(OF_floatarith1_${clust}) latency(OL_floatdiv) resv(RT_${clust}_${idx}));
      SA_floatarith2_float_${clust}_${idx}(format(OF_floatarith2_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
      SA_floatarith2_floatdiv_${clust}_${idx}(format(OF_floatarith2_${clust}) latency(OL_floatdiv) resv(RT_${clust}_${idx}));
      SA_floatarith2_floatmpy_${clust}_${idx}(format(OF_floatarith2_${clust}) latency(OL_floatmpy) resv(RT_${clust}_${idx}));
      SA_floatarith3_floatmpy_${clust}_${idx}(format(OF_floatarith3_${clust}) latency(OL_floatmpy) resv(RT_${clust}_${idx}));

      SA_floatcmpr_float_${clust}_${idx}(format(OF_floatcmpr_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
      SA_floatcmpp_float_${clust}_${idx}(format(OF_floatcmpp_${clust}) latency(OL_floatcmpp) resv(RT_${clust}_${idx}));

      SA_convif_float_${clust}_${idx}(format(OF_moveif_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
      SA_convff_float_${clust}_${idx}(format(OF_moveff_${clust}_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
      SA_convfi_float_${clust}_${idx}(format(OF_movefi_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));

      // HPL-PD 2.0 Extn
      SA_floatlitmove_float_${clust}_${idx}(format(OF_floatlitmove_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));

      // Intra-cluster float move
      SA_moveff_float_${clust}_${clust}_${idx}(format(OF_moveff_${clust}_${clust}) latency(OL_float) resv(RT_${clust}_${idx}));
    }
  }

  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      // standard loads
      $for(format in intload intloadinc floatload floatloadinc intloadgdisp 
           intloadmdisp intloadext intloadgdispext intloadmdispext floatloadgdisp floatloadmdisp) {
        $for((src in C1 C2 C3) (lat in load1 load2 load3)) {
  	  SA_${format}_std_${src}_${clust}_${idx}(format(OF_${format}_${clust}) latency(OL_${lat}) resv(RT_${clust}_${idx}));
        }
      }

      // speculative loads
      $for(format in intload intloadinc floatload floatloadinc) {
        $for((src in C1 C2 C3) (lat in dsload1 dsload2 dsload3)) {
	  SA_${format}_spec_${src}_${clust}_${idx}(format(OF_${format}_${clust}) latency(OL_${lat}) resv(RT_${clust}_${idx}));
        }
      }

      // speculative load verify
      SA_intload_verify_${clust}_${idx}(format(OF_intload_${clust}) latency(OL_dsload_verify) resv(RT_${clust}_${idx})); 
      SA_floatload_verify_${clust}_${idx}(format(OF_floatload_${clust}) latency(OL_dsload_verify) resv(RT_${clust}_${idx}));

      // standard stores
      $for(format in intstore intstoreinc floatstore floatstoreinc intstoregdisp intstoremdisp floatstoremdisp floatstoregdisp){
        SA_${format}_std_${clust}_${idx}(format(OF_${format}_${clust}) latency(OL_store) resv(RT_${clust}_${idx}));
      }

      SA_moveif_C1_${clust}_${idx}(format(OF_moveif_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
      SA_movefi_C1_${clust}_${idx}(format(OF_movefi_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
      SA_predload_C1_${clust}_${idx}(format(OF_predload_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
      SA_predstore_store_${clust}_${idx}(format(OF_predstore_${clust}) latency(OL_store) resv(RT_${clust}_${idx}));

      // Explicit save/restore formats - Shail Aditya 05/26/98
      SA_intsave_store_${clust}_${idx}(format(OF_intsave_${clust}) latency(OL_store) resv(RT_${clust}_${idx}));
      SA_intrestore_C1_${clust}_${idx}(format(OF_intrestore_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
      SA_floatsave_store_${clust}_${idx}(format(OF_floatsave_${clust}) latency(OL_store) resv(RT_${clust}_${idx}));
      SA_floatrestore_C1_${clust}_${idx}(format(OF_floatrestore_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
      SA_brsave_store_${clust}_${idx}(format(OF_brsave_${clust}) latency(OL_store) resv(RT_${clust}_${idx}));
      SA_brrestore_C1_${clust}_${idx}(format(OF_brrestore_${clust}) latency(OL_load1) resv(RT_${clust}_${idx}));
    }
  }

  $for(clust in $0.. (num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {
      SA_brucond_branch_${clust}_${idx}(format(OF_brucond_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brcond_branch_${clust}_${idx}(format(OF_brcond_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brlink_branch_${clust}_${idx}(format(OF_brlink_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brtop_branch_${clust}_${idx}(format(OF_brtop_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brlc_branch_${clust}_${idx}(format(OF_brlc_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brdvi_branch_${clust}_${idx}(format(OF_brdvi_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
      SA_brdvf_branch_${clust}_${idx}(format(OF_brdvf_${clust}) latency(OL_branch) resv(RT_${clust}_${idx}));
    }
  }

  // HPL-PD 2.0 Extn
  $if (${local_memory_units} != 0) {
    $for(clust in $0.. (num_clusters-1)) {
      $for (idx in $0..(exec_units-1)) {
        SA_intload_localmem_${clust}_lm${idx}(format(OF_intload_${clust}) latency(OL_load_localmem) resv(RT_${clust}_lm${idx}));
        SA_floatload_localmem_${clust}_lm${idx}(format(OF_floatload_${clust}) latency(OL_load_localmem) resv(RT_${clust}_lm${idx}));
        SA_intstore_localmem_${clust}_lm${idx}(format(OF_intstore_${clust}) latency(OL_store_localmem) resv(RT_${clust}_lm${idx}));
        SA_floatstore_localmem_${clust}_lm${idx}(format(OF_floatstore_${clust}) latency(OL_store_localmem) resv(RT_${clust}_lm${idx}));
      }
    }
  }
}

// *************************************************************
// HPL-PD Operations (Architecture Version 1.0)

SECTION Operation
{
  // **** Integer operations ****
  $for (clust in $0..(num_clusters-1)) {
    $for (idx in $0..(exec_units-1)) {

      // Table 2: Integer computation operations 
      $for (class in intarith1_int intarith2_int intarith2_intshift intarith2_intdiv intarith2_intmpy intarith3_intmpy) {
        $for (op in ${OP_${class}}) {
	  $for(w in ${int_alu_widths}) {
	    "${op}_${w}_${clust}.${idx}"(alt(SA_${class}_${clust}_${idx}));
	  }
        }
      }


      // Saturating arithmetic
      $for (class in intarith2_intsatadd intarith2_intsataddl intarith2_intsatsub intarith2_intsatsubl 
                     intarith2_intsatmpy intarith2_intsatmpyl intarith3_intsatmpyadd intarith3_intsatmpyaddn 
                     intarith3_intsatmpysub intarith3_intsatmpyrsub) {
        $for (op in ${OP_${class}}) {
	  $for(w in ${int_alu_widths}) {
	    $for (i in $1..32) {
  	      "${op}${i}_${w}_${clust}.${idx}"(alt(SA_${class}_${clust}_${idx}));
	    }
	  }
        }
      }

      // Table 4: Conversion operations 
      $for(op in ${OP_sign_extend}){
        $for(w in ${int_extract_widths}){
 	  "${op}_${w}_${clust}.${idx}"(alt(SA_sext_int_${clust}_${idx}));
        }
      }

      // Bit extraction ops
      $for (op in ${OP_bit_extraction}) {
        $for(w in ${int_alu_widths}){
	  "${op}_${w}_${clust}.${idx}"(alt(SA_bit_extraction_${clust}_${idx}));
	}
      }

      // Table 5: Move operations

//  Operations to be included in the future.  mchu (7.24.2003)

//      $for(class in movepi movegbp movegcm){
//        $for(op in ${OP_${class}}){
//	  "${op}_${clust}.${idx}"(alt(SA_${class}_int_${clust}_${idx}));
//        }
//      }

//      $for(class in moveip){
//        $for(op in ${OP_${class}}){
//	  "${op}_${clust}.${idx}"(alt(SA_${class}_int_${clust}_${idx}));
//        }
//      }


      $for (clust2 in $0..(num_clusters-1)) {
        $for(class in moveii) {
          $for(op in ${OP_${class}}) {
            $if(${clust} == ${clust2}) {
	      "${op}_${clust}_${clust2}.${idx}"(alt(SA_${class}_int_${clust}_${clust2}_${idx}));
	    }
          }
        }
      }

      // Mass clear operation for PR
      $for(op in ${OP_mass_pred_clear}) {
       "${op}_${clust}.${idx}"(alt(SA_pred_int_${clust}_${idx}));
      }

      // Move pred operations
      $for (clust2 in $0..(num_clusters-1)) {
        $for(class in movepp) {
          $for(op in ${OP_${class}}) {
            $if(${clust} == ${clust2}) {	
	      "${op}_${clust}_${clust2}.${idx}"(alt(SA_${class}_int_${clust}_${clust2}_${idx}));
	    }
          }
        }
      }

      $for(op in ${OP_pred_writes}){
        "${op}_${clust}.${idx}"(alt(SA_pred_null_${clust}_${idx}));
      }

      // HPL-PD 2.0 Extn
      // Split moves instead of MOVE
      $for (clust2 in $0..(num_clusters-1)) {
        $for(class in movegc movecg){
          $for(op in ${OP_${class}}) {
            $if(${clust} == ${clust2}) {
	      "${op}_${clust}_${clust2}.${idx}"(alt(SA_${class}_int_${clust}_${clust2}_${idx}));
	    }
          }
        }
      }

      // HPL-PD 2.0 Extn
      // Split moves instead of MOV
      $for (clust2 in $0..(num_clusters-1)) {
        $for(class in movegg movebb){
          $for(op in ${OP_${class}}) {
            $if(${clust} == ${clust2}) {
  	      "${op}_${clust}_${clust2}.${idx}"(alt(SA_${class}_int_${clust}_${clust2}_${idx}));
	    }
          }
        }
      }

      // Int literal moves to GPR. 
      // This also takes care of PCB moves for WIMS. (pnagarka)
      $for(op in ${OP_int_literal_moves}) {
        "${op}_${clust}.${idx}"(alt(SA_intlitmove_int_${clust}_${idx}));
      }

      // WIMS Copy op. 	
      $for(op in ${OP_lc_copy}) {
        "${op}_${clust}.${idx}"(alt(SA_lc_copy_int_${clust}_${idx}));
      }

      // Table 8: Compare-to-register operations
      $for(op in ${OP_int_compare_to_reg}){
        $for(w in ${int_alu_widths}){
	  $for(ic in ${integer_compare_conds}){
	    "${op}_${w}_${ic}_${clust}.${idx}"(alt(SA_intcmpr_int_${clust}_${idx}));
  	  }
        }
      }

      // Table 9: Two-target compare-to-predicate operations
      $for(op in ${OP_int_cmp_pred_two}){
        $for(w in ${int_alu_widths}){
	  $for(ic in ${integer_compare_conds}){
	    $for(da1 in ${cmpp_dest_actions}){
	      $for(da2 in ${cmpp_dest_actions}){	
	        "${op}_${w}_${ic}_${da1}_${da2}_${clust}.${idx}"(alt(SA_intcmpp_int_${clust}_${idx}));
  	      }
	    }
	  }
        }
      }

/*  ----------
      // HPL-PD 2.0 extension: One target compare to predicate operations. 
      $for(op in ${OP_int_cmp_pred_one}){
        $for(w in ${int_alu_widths}){
	  $for(ic in ${integer_compare_conds}){
	    $for(da1 in ${cmpp_dest_actions}){
	      "${op}_${w}_${ic}_${da1}_${clust}.${idx}"(alt(SA_intcmppi_int_${clust}_i${idx}));
            }
       	  }
        }
      }
--------- */

      // Table 16: Prepare to branch (cast on int unit)
      $for(op in ${OP_pbrs}){
        "${op}_${clust}.${idx}"(alt(SA_branch_int_${clust}_${idx}));
      }

      // HPL-PD 2.0 extn
      // literal moves to BTR
      $for(op in ${OP_btr_literal_moves}) {
        "${op}_${clust}.${idx}"(alt(SA_btrlitmove_int_${clust}_${idx}));
      }
    } // end **** Integer Operations ****
  } // end {clust}


  // **** Float Operations ****
  
  $for (clust in $0..(num_clusters-1)) {
    $for (idx in $0..(exec_units-1)){

      // Table 3: Floating-point computation operations
      $for (class in floatarith1_float floatarith1_floatdiv floatarith2_float 
                     floatarith2_floatdiv floatarith2_floatmpy floatarith3_floatmpy) {
        $for(op in ${OP_${class}}) {
	  $for(w in ${float_widths}) {
	    "${op}_${w}_${clust}.${idx}"(alt(SA_${class}_${clust}_${idx}));
          }
        }
      }

      // Table 4: Conversion operations 
      $for(class in convif convfi convff){
        $for(op in ${OP_${class}}){
	  "${op}_${clust}.${idx}"(alt(SA_${class}_float_${clust}_${idx}));
        }
      }

      // Table 5: Move operations
      $for (clust2 in $0..(num_clusters-1)) {      
        $for(op in ${OP_moveff}){
          $for(w in ${float_widths}){
            $if(${clust} == ${clust2}) {
              "${op}_${w}_${clust}_${clust2}.${idx}"(alt(SA_moveff_float_${clust}_${clust2}_${idx}));
	    }
          }
        }
      }

      // HPL-PD 2.0 Extn
      // Float literal moves to FPR
      $for(op in ${OP_float_literal_moves}) {
        "${op}_${clust}.${idx}"(alt(SA_floatlitmove_float_${clust}_${idx}));
      }

      // Table 8: Compare-to-register operations
      $for(op in ${OP_float_compare_to_reg}){
        $for(w in ${float_widths}){
	  $for(fc in ${float_compare_conds}){
	    "${op}_${w}_${fc}_${clust}.${idx}"(alt(SA_floatcmpr_float_${clust}_${idx}));
	  }
        }
      }

      // Table 9: Two-target compare-to-predicate operations
      $for(op in ${OP_float_cmp_pred_two}){
        $for(w in ${float_widths}){
	  $for(fc in ${float_compare_conds}){
	    $for(da1 in ${cmpp_dest_actions}){
	      $for(da2 in ${cmpp_dest_actions}){	
	        "${op}_${w}_${fc}_${da1}_${da2}_${clust}.${idx}"(alt(SA_floatcmpp_float_${clust}_${idx}));
              }
	    }
	  }
        }
      }
      
/*  ----------
      // HPL-PD 2.0 extension: One target compare to predicate operations. 
      $for(op in ${OP_float_cmp_pred_one}){
        $for(w in ${float_widths}){
	  $for(fc in ${float_compare_conds}){
	    $for(da1 in ${cmpp_dest_actions}){
	      "${op}_${w}_${fc}_${da1}_${clust}.${idx}"(alt(SA_floatcmppi_float_${clust}_f${idx}));
	    }
	  }
        }
      }
--------- */
    } // end **** Float Operations ****
  } // end {clust}


  // ****; Memory Operations ****
  
  $for (clust in $0..(num_clusters-1)) {
    $for (idx in $0..(exec_units-1)){

      // Table 5: Move operations
      $for (class in moveif movefi){
        $for(op in ${OP_${class}}){
	  $for(rh in ${float_register_halves}){
	    "${op}_${rh}_${clust}.${idx}"(alt(SA_${class}_C1_${clust}_${idx}));
	  }
        }
      }

      // Table 12, 13, 14: Load/store operations for cache/main memory
      // Integer load ops
      $for(class in intload_std intloadinc_std intload_spec intloadinc_spec intloadgdisp_std 
                    intloadmdisp_std intloadext_std intloadgdispext_std intloadmdispext_std) {
        $for(op in ${OP_${class}}){
	  $for(ss in ${latency_src_cache_specifiers}){
	    $for(ts in ${load_target_cache_specifiers}){
	      $for(w in ${int_mem_widths}){
	        "${op}_${w}_${ss}_${ts}_${clust}.${idx}"(alt(SA_${class}_${ss}_${clust}_${idx}));
	      }
	    }
	  }
        }
      }

      // Float load ops
      $for(class in floatload_std floatloadinc_std floatload_spec floatloadinc_spec floatloadgdisp_std floatloadmdisp_std){
        $for(op in ${OP_${class}}){
	  $for(ss in ${latency_src_cache_specifiers}){
	    $for(ts in ${load_target_cache_specifiers}){
	      $for(w in ${float_widths}){
	        "${op}_${w}_${ss}_${ts}_${clust}.${idx}"(alt(SA_${class}_${ss}_${clust}_${idx}));
	      }
	    }
	  }
        }
      }

      // Integer store ops
      $for(class in intstore_std intstoreinc_std intstoremdisp_std intstoregdisp_std){
        $for(op in ${OP_${class}}){
	  $for(ts in ${store_target_cache_specifiers}){
	    $for(w in ${int_mem_widths}){
	      "${op}_${w}_${ts}_${clust}.${idx}"(alt(SA_${class}_${clust}_${idx}));
	    }
	  }
        }
      }

      // Float store ops
      $for(class in floatstore_std floatstoreinc_std floatstoremdisp_std floatstoregdisp_std){
        $for(op in ${OP_${class}}){
	  $for(ts in ${store_target_cache_specifiers}){
	    $for(w in ${float_widths}){
	      "${op}_${w}_${ts}_${clust}.${idx}"(alt(SA_${class}_${clust}_${idx}));
	    }
	  }
        }
      }

      // Int ldv ops
      $for(op in ${OP_intload_dv}){
        $for(w in ${int_mem_widths}){
	  "${op}_${w}_${clust}.${idx}"(alt(SA_intload_verify_${clust}_${idx}));
        }
      }

      // Float ldv ops
      $for(op in ${OP_floatload_dv}){
        $for(w in ${float_widths}){
	  "${op}_${w}_${clust}.${idx}"(alt(SA_floatload_verify_${clust}_${idx}));
        }
      }

      // Explicit save/restore formats - Shail Aditya 05/26/98
      $for(class in intsave floatsave brsave){
        $for(op in ${OP_${class}}){
	  "${op}_${clust}.${idx}"(alt(SA_${class}_store_${clust}_${idx}));
        }
      }
      $for(class in intrestore floatrestore brrestore){
        $for(op in ${OP_${class}}){
	  "${op}_${clust}.${idx}"(alt(SA_${class}_C1_${clust}_${idx}));
        }
      }

      // Operations for predicate spilling. These will go away soon.
      $for(op in ${OP_pfill}){
        "${op}_${clust}.${idx}"(alt(SA_predload_C1_${clust}_${idx}));
      }
      $for(op in ${OP_pspill}){
        "${op}_${clust}.${idx}"(alt(SA_predstore_store_${clust}_${idx}));
      }

    } // end **** Memory Operations ****
  } // end {clust} 

  // HPL-PD 2.0 Extn
  // **** Local Memory Operations ****
  /*
  $if (${local_memory_units} != 0) {
    $for(lm in ${local_memory_specifiers}){
      $for (idx in $0..(local_memory_units-1)){

        $for(op in ${OP_intload_local}){
	  $for(w in ${int_mem_widths}){
	    "${op}_${w}_${lm}.${idx}"(alt(SA_intload_localmem_lm${idx}));
	  }
        }
        $for(op in ${OP_floatload_local}){
	  $for(w in ${float_widths}){
	    "${op}_${w}_${lm}.${idx}"(alt(SA_floatload_localmem_lm${idx}));
	  }
        }
        $for(op in ${OP_intstore_local}){
	  $for(w in ${int_mem_widths}){
	    "${op}_${w}_${lm}.${idx}"(alt(SA_intstore_localmem_lm${idx}));
	  }
        }
        $for(op in ${OP_floatstore_local}){
	  $for(w in ${float_widths}){
	    "${op}_${w}_${lm}.${idx}"(alt(SA_floatstore_localmem_lm${idx}));
	  }
        }
      }
    }  
  } // end *** Local Memory Operations **** */

  // **** Branch Operations ****
  
  $for (clust in $0..(num_clusters-1)) {
    $for (idx in $0..(exec_units-1)){
      $for(class in brucond brcond brlink brlc brtop brdvi brdvf){
        $for(op in ${OP_${class}}){
	  "${op}_${clust}.${idx}"(alt(SA_${class}_branch_${clust}_${idx}));
        }
      }
    } 
  } // end **** Branch Operations ****
  

  // **** Intercluster move operations ****
  /*
  $for (clust in $0..(num_clusters-1)) {
    $for (clust2 in $0..(num_clusters-1)) {
      $for (idx in $0..(icmove_bw-1)) {
        $for(class in movegg movebb movegc movecg movepp moveii){
          $for(op in ${OP_${class}}) {
            $if(${clust} != ${clust2}) {
    	      "${op}_${clust}_${clust2}.${idx}"(alt(SA_${class}_int_${clust}_${clust2}_${idx}));
            }
          }
        }

        $for(op in ${OP_moveff} ){
          $for(w in ${float_widths}){
            $if(${clust} != ${clust2}) {
              "${op}_${w}_${clust}_${clust2}.${idx}"(alt(SA_moveff_float_${clust}_${clust2}_${idx}));
            }
          }
        }
      }
    }
  } // end **** Intercluster move operations ****
  */
}
